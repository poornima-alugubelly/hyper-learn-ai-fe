name: Automated npm Updates

on:
  schedule:
    - cron: '0 9 * * 1'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (no PR created)'
        required: false
        default: false
        type: boolean

jobs:
  update-dependencies:
    runs-on: ubuntu-latest
    permissions: # Explicitly set permissions for GITHUB_TOKEN
      contents: write
      pull-requests: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        # Use a PAT if you need to trigger other workflows or have cross-repo needs
        # Otherwise, GITHUB_TOKEN with appropriate permissions (set above) is fine.
        token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }} 
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install current dependencies
      run: npm install
    
    - name: Create backup and excluded packages list
      run: |
        # Define packages to exclude from updates
        EXCLUDED_PACKAGES=(
          "react"
          "react-dom"
          "@types/node"
          "typescript"
          "webpack"
          "eslint"
          "jest"
          "lodash"
          "express"
          "axios"
        )
        
        # Create backups
        cp package.json package.json.backup
        cp package-lock.json package-lock.json.backup
        
        # Store excluded packages in environment
        echo "EXCLUDED_PACKAGES=${EXCLUDED_PACKAGES[*]}" >> $GITHUB_ENV
    
    - name: Update packages selectively
      run: |
        echo "Attempting to get outdated packages list..."
        # Try to get JSON. If npm outdated fails or output is not JSON, default to empty object.
        # Use --loglevel error to reduce noise from npm itself on stdout.
        # Use jq to validate and ensure we only pass valid JSON to the node script.
        # jq -c . will compact the JSON and error if it's not valid.
        OUTDATED_JSON=$(npm outdated --json --loglevel error | jq -c . 2>/dev/null || echo '{}')
        
        echo "---BEGIN OUTDATED_JSON (processed by jq or fallback)---"
        echo "$OUTDATED_JSON"
        echo "---END OUTDATED_JSON---"

        # Parse and update packages individually
        node -e "
          const outdatedJsonString = \`$OUTDATED_JSON\`; // Using backticks for multi-line string (though jq -c makes it single line)
          let outdated;

          try {
            outdated = JSON.parse(outdatedJsonString);
          } catch (e) {
            console.error('SyntaxError while parsing OUTDATED_JSON: ', e.message);
            console.error('Problematic JSON string was (may be truncated if very long):');
            console.error(outdatedJsonString.substring(0, 1000)); // Print the string that caused the error (or first 1KB)
            process.exit(1); // Exit with an error code
          }
          
          const excluded = (process.env.EXCLUDED_PACKAGES || '').split(' ');
          
          if (Object.keys(outdated).length === 0) {
            console.log('No outdated packages to update (or npm outdated failed/produced no valid JSON).');
          } else {
            for (const [pkg, info] of Object.entries(outdated)) {
              if (info && typeof info === 'object' && info.current && info.wanted) { // Add a check for valid info structure
                if (!excluded.includes(pkg)) {
                  console.log(\`Updating '\${pkg}' from '\${info.current}' to '\${info.wanted}'\`);
                  try {
                    require('child_process').execSync(\`npm install \${pkg}@\${info.wanted}\`, {stdio: 'inherit'});
                  } catch (installError) {
                    console.error(\`Failed to install \${pkg}@\${info.wanted}: \${installError.message}\`);
                    // Optionally, decide if you want to fail the step here or continue
                  }
                } else {
                  console.log(\`Skipping excluded package: '\${pkg}'\`);
                }
              } else {
                console.warn(\`Skipping package '\${pkg}' due to unexpected info structure:\`, info);
              }
            }
          }
        "
    - name: Verify no excluded packages were updated
      run: |
        IFS=' ' read -ra EXCLUDED <<< "$EXCLUDED_PACKAGES"
        
        for package in "${EXCLUDED[@]}"; do
          # Get the original specifier from the backup package.json
          ORIGINAL_SPECIFIER=$(node -e "
            const fs = require('fs');
            let specifier = undefined;
            try {
              const backup = JSON.parse(fs.readFileSync('package.json.backup', 'utf8'));
              if (backup.dependencies && backup.dependencies['$package']) {
                specifier = backup.dependencies['$package'];
              } else if (backup.devDependencies && backup.devDependencies['$package']) {
                specifier = backup.devDependencies['$package'];
              }
            } catch(e) { 
              // console.error('Error reading backup package.json for $package:', e.message); 
            }
            if (specifier !== undefined) console.log(specifier);
          ")

          # If the package was not in the original dependencies, check if it was added.
          # If it was added and is in the excluded list, it should be removed.
          if [ -z "$ORIGINAL_SPECIFIER" ]; then
            # Check if package is currently listed in package.json (not just installed in node_modules)
            if node -e "const pkg = JSON.parse(require('fs').readFileSync('package.json', 'utf8')); console.log(!!(pkg.dependencies && pkg.dependencies['$package'] || pkg.devDependencies && pkg.devDependencies['$package']))" | grep -q true; then
                echo "⚠️ Excluded package '$package' was not in original dependencies but is now present. Removing."
                npm uninstall "$package"
            fi
            continue # Move to next excluded package
          fi

          # Get the current specifier from the current package.json
          CURRENT_SPECIFIER=$(node -e "
            const fs = require('fs');
            let specifier = undefined;
            try {
              const current = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              if (current.dependencies && current.dependencies['$package']) {
                specifier = current.dependencies['$package'];
              } else if (current.devDependencies && current.devDependencies['$package']) {
                specifier = current.devDependencies['$package'];
              }
            } catch(e) { 
              // console.error('Error reading current package.json for $package:', e.message); 
            }
            if (specifier !== undefined) console.log(specifier);
          ")

          # If current specifier is missing (package removed) or different from original, restore.
          if [ "$CURRENT_SPECIFIER" != "$ORIGINAL_SPECIFIER" ]; then
            if [ -z "$CURRENT_SPECIFIER" ]; then
              echo "⚠️ Excluded package '$package' was removed. Restoring to '$ORIGINAL_SPECIFIER'."
            else
              echo "⚠️ Specifier for excluded package '$package' changed from '$ORIGINAL_SPECIFIER' to '$CURRENT_SPECIFIER'. Restoring."
            fi
            
            # Determine how to install to preserve the original specifier type
            # npm install <pkg>@<original_specifier_string> will generally preserve the specifier type
            # (e.g. ^, ~, exact, tag) in package.json as long as the specifier is valid.
            echo "   Installing with original specifier: ${package}@${ORIGINAL_SPECIFIER}"
            npm install "${package}@${ORIGINAL_SPECIFIER}"
          else
            echo "✅ Excluded package '$package' specifier ('$ORIGINAL_SPECIFIER') preserved."
          fi
        done

    - name: Clean up backup files
      if: always() # Always run this step, even if previous steps fail
      run: |
        rm -f package.json.backup package-lock.json.backup
    
    - name: Check for changes
      id: git-check
      run: |
        if git diff --quiet HEAD -- package.json package-lock.json; then # Compare against HEAD to ensure we see committed changes too
          echo "changes=false" >> $GITHUB_OUTPUT
          echo "No changes detected in package.json or package-lock.json"
        else
          echo "changes=true" >> $GITHUB_OUTPUT
          echo "Changes detected:"
          git diff --name-only HEAD -- package.json package-lock.json
        fi
    
    - name: Show what was updated
      if: steps.git-check.outputs.changes == 'true'
      run: |
        echo "📦 Updated packages (diff on package.json):"
        git diff HEAD -- package.json | grep -E '^\+.*".*":' | sed 's/^+//' || echo "No direct dependency changes in package.json diff"
        echo ""
        echo "📊 Package-lock changes (stat):"
        git diff --stat HEAD -- package-lock.json

    - name: Generate branch name
      if: steps.git-check.outputs.changes == 'true' # Only generate if there are changes
      id: vars
      run: echo "branch_name=automated-npm-updates-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
    
    - name: Create Pull Request
      if: steps.git-check.outputs.changes == 'true' && github.event.inputs.dry_run != 'true'
      uses: peter-evans/create-pull-request@v5 # Consider updating to v6 if available and compatible
      with:
        token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
        commit-message: "chore: update npm dependencies (selective)"
        title: "🔄 Selective npm dependencies update"
        body: |
          ## 📦 Selective npm Dependencies Update
          
          This PR updates npm dependencies while preserving pinned/ranged package versions for excluded packages.
          
          ### 🚫 Excluded Packages (Specifiers Preserved)
          The version specifiers for the following packages were preserved as they were:
          ```
          ${{ env.EXCLUDED_PACKAGES }}
          ```
          
          ### 📋 What Changed
          - Updated outdated non-excluded packages to their latest compatible versions (`info.wanted` from `npm outdated`).
          - Preserved original version specifiers (e.g., `^1.2.3`, `~1.2.3`, `1.2.3`) of excluded packages.
          
          ### ✅ Pre-merge Checklist
          - [ ] Review the updated package versions in `package.json` and `package-lock.json`.
          - [ ] Run tests locally to verify compatibility.
          - [ ] Check for any breaking changes in updated packages.
          
          ### 🔍 How to Test Locally
          ```bash
          # The branch name will be: ${{ steps.vars.outputs.branch_name }}
          git fetch origin
          git checkout ${{ steps.vars.outputs.branch_name }}
          npm install
          npm test  # or your test command
          npm run build  # or your build command
          ```
          
          ---
          *This PR was created automatically by GitHub Actions*
        branch: ${{ steps.vars.outputs.branch_name }}
        delete-branch: true