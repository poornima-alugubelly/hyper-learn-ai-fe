name: Automated npm Updates

on:
  schedule:
    - cron: '0 9 * * 1'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (no PR created)'
        required: false
        default: false
        type: boolean

jobs:
  update-dependencies:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }} 
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install current dependencies
      run: npm install --ignore-scripts
    
    - name: Create backup and define exclusion lists
      run: |
        # Define packages to exclude by EXACT NAME
        EXCLUDED_PACKAGES_EXACT=(
          "@types/node"
          "typescript"
          "webpack"
          "eslint"
          "jest"
          "lodash"
          "express"
          "axios"
        )

        # Define SUBSTRINGS to identify packages for exclusion
        # If a package name CONTAINS any of these, it will be excluded.
        # Be careful with overly broad substrings.
        EXCLUDED_SUBSTRINGS=(
          "dom"
        )
        
        # Create backups
        cp package.json package.json.backup
        cp package-lock.json package-lock.json.backup
        
        echo "EXCLUDED_PACKAGES_EXACT_STR=${EXCLUDED_PACKAGES_EXACT[*]}" >> $GITHUB_ENV
        echo "EXCLUDED_SUBSTRINGS_STR=${EXCLUDED_SUBSTRINGS[*]}" >> $GITHUB_ENV
        echo "Original package.json and package-lock.json backed up."
        echo "Exclusion Lists:"
        echo "Exact names: ${EXCLUDED_PACKAGES_EXACT[*]}"
        echo "Substrings: ${EXCLUDED_SUBSTRINGS[*]}"
    
    - name: Temporarily Pin Excluded Packages (by Exact Name or Substring)
      env:
        EXACT_NAMES_ENV: ${{ env.EXCLUDED_PACKAGES_EXACT_STR }}
        SUBSTRINGS_ENV: ${{ env.EXCLUDED_SUBSTRINGS_STR }}
      run: |
        echo "Temporarily pinning excluded packages in live package.json..."
        node -e "
          const fs = require('fs');
          const child_process = require('child_process');
          
          const exactExcluded = (process.env.EXACT_NAMES_ENV || '').split(' ').filter(p => p);
          const substringExcluded = (process.env.SUBSTRINGS_ENV || '').split(' ').filter(p => p);

          if (exactExcluded.length === 0 && substringExcluded.length === 0) {
            console.log('No exclusion rules defined. Nothing to pin.');
            process.exit(0);
          }

          const pkgJsonPath = 'package.json';
          let livePkgJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8')); // The one we'll modify
          const backupPkgJson = JSON.parse(fs.readFileSync('package.json.backup', 'utf8')); // Source of all deps
          const backupLockJson = JSON.parse(fs.readFileSync('package-lock.json.backup', 'utf8'));

          let packagesToPin = new Set();
          const allDepsFromBackup = { ...(backupPkgJson.dependencies || {}), ...(backupPkgJson.devDependencies || {}) };

          console.log('Identifying packages to pin based on exclusion rules:');
          for (const depName in allDepsFromBackup) {
            let isExcluded = false;
            if (exactExcluded.includes(depName)) {
              isExcluded = true;
              console.log(`  - '\${depName}' matched exact exclusion list.`);
            }
            if (!isExcluded) {
              for (const substr of substringExcluded) {
                if (depName.includes(substr)) {
                  isExcluded = true;
                  console.log(`  - '\${depName}' matched substring '\${substr}'.`);
                  break;
                }
              }
            }
            if (isExcluded) {
              packagesToPin.add(depName);
            }
          }
          
          if (packagesToPin.size === 0) {
            console.log('No packages identified for pinning based on current dependencies and exclusion rules.');
            process.exit(0);
          }

          console.log('Packages to be pinned:', Array.from(packagesToPin));
          let changedInLivePkgJson = false;

          for (const depNameToPin of packagesToPin) {
            let currentResolvedVersion = null;
            // Try to get from package-lock.json's 'packages' structure (npm v7+)
            if (backupLockJson.packages && backupLockJson.packages[\`node_modules/\${depNameToPin}\`]) {
                currentResolvedVersion = backupLockJson.packages[\`node_modules/\${depNameToPin}\`].version;
            } 
            // Fallback for older lockfiles or direct dependencies not in 'packages' but in 'dependencies' block of lockfile
            else if (backupLockJson.dependencies && backupLockJson.dependencies[depNameToPin]) {
                 currentResolvedVersion = backupLockJson.dependencies[depNameToPin].version;
            }
            // As a last resort, try npm list (slower)
            else {
                try {
                    console.log(\`Attempting npm list for \${depNameToPin} as fallback to find resolved version...\`);
                    const listOutput = child_process.execSync(\`npm list \${depNameToPin} --json --depth=0\`, { encoding: 'utf8' });
                    const listParsed = JSON.parse(listOutput);
                    if (listParsed.dependencies && listParsed.dependencies[depNameToPin]) {
                        currentResolvedVersion = listParsed.dependencies[depNameToPin].version;
                    }
                } catch (e) {
                    console.warn(\`Could not determine resolved version for '\${depNameToPin}' via npm list: \${e.message.split('\\n')[0]}\`);
                }
            }

            if (currentResolvedVersion) {
              console.log(\`  Found resolved version for '\${depNameToPin}': \${currentResolvedVersion}\`);
              let targetSection = null;
              if (livePkgJson.dependencies && livePkgJson.dependencies[depNameToPin]) targetSection = 'dependencies';
              else if (livePkgJson.devDependencies && livePkgJson.devDependencies[depNameToPin]) targetSection = 'devDependencies';

              if (targetSection) {
                if (livePkgJson[targetSection][depNameToPin] !== currentResolvedVersion) {
                  console.log(\`    Pinning '\${depNameToPin}' in \${targetSection} from '\${livePkgJson[targetSection][depNameToPin]}' to '\${currentResolvedVersion}'\`);
                  livePkgJson[targetSection][depNameToPin] = currentResolvedVersion;
                  changedInLivePkgJson = true;
                } else {
                  console.log(\`    '\${depNameToPin}' in \${targetSection} is already pinned to '\${currentResolvedVersion}'. No change needed.\`);
                }
              } else {
                console.warn(\`  Excluded package '\${depNameToPin}' (intended for pinning) not found in live package.json dependencies or devDependencies.\`);
              }
            } else {
              console.warn(\`  Could not find resolved version for excluded package '\${depNameToPin}'. It might not be installed or is a sub-dependency not listed directly. Skipping pinning for this package.\`);
            }
          }

          if (changedInLivePkgJson) {
            fs.writeFileSync(pkgJsonPath, JSON.stringify(livePkgJson, null, 2) + '\\n');
            console.log('Live package.json updated with pinned versions for identified excluded packages.');
          } else {
            console.log('No changes made to live package.json for pinning (either no packages to pin or already pinned).');
          }
        "
    
    - name: Run npm update (respecting temporarily pinned versions)
      run: |
        echo "Running npm update..."
        npm update --ignore-scripts || echo "npm update completed with non-zero exit code, proceeding..."
        echo "npm update finished."

    - name: Restore Original package.json
      run: |
        echo "Restoring original package.json from backup..."
        cp package.json.backup package.json
        echo "Original package.json restored."

    - name: Run Final npm install
      run: |
        echo "Running final npm install to ensure consistency..."
        npm install --ignore-scripts
        echo "Final npm install finished."

    - name: Clean up backup files
      if: always()
      run: |
        rm -f package.json.backup package-lock.json.backup
    
    - name: Check for changes
      id: git-check
      run: |
        if git diff --quiet HEAD -- package.json package-lock.json; then
          echo "changes=false" >> $GITHUB_OUTPUT
          echo "No changes detected in package.json or package-lock.json after update process."
        else
          echo "changes=true" >> $GITHUB_OUTPUT
          echo "Changes detected:"
          git diff --name-only HEAD -- package.json package-lock.json
        fi
    
    - name: Show what was updated
      if: steps.git-check.outputs.changes == 'true'
      run: |
        echo "📦 Updated packages (diff on package.json):"
        git diff HEAD -- package.json | grep -E '^\+.*".*":' | sed 's/^+//' || echo "No direct dependency changes in package.json diff"
        echo ""
        echo "📊 Package-lock changes (stat):"
        git diff --stat HEAD -- package-lock.json

    - name: Generate branch name
      if: steps.git-check.outputs.changes == 'true' 
      id: vars
      run: echo "branch_name=automated-npm-updates-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
    
    - name: Create Pull Request
      if: steps.git-check.outputs.changes == 'true' && github.event.inputs.dry_run != 'true'
      uses: peter-evans/create-pull-request@v5 
      with:
        token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
        commit-message: "chore: update npm dependencies (preserving excluded by name/substring)"
        title: "🔄 NPM Update (preserving excluded packages)"
        body: |
          ## 📦 NPM Dependencies Update
          
          This PR updates npm dependencies using `npm update`, while attempting to preserve the state of excluded packages.
          Packages are excluded if their name is an exact match in one list OR if their name contains a substring from another list.
          
          ### 🚫 Excluded Packages (Attempted Preservation)
          **Exact Name Matches Targeted for Preservation:**
          ```
          ${{ env.EXCLUDED_PACKAGES_EXACT_STR }}
          ```
          **Substring Matches Targeted for Preservation (packages containing these):**
          ```
          ${{ env.EXCLUDED_SUBSTRINGS_STR }}
          ```
          
          ### 📋 What Changed
          - `npm update` was run to update non-excluded direct dependencies and all transitive dependencies.
          - Original version specifiers for all identified excluded packages were restored to `package.json`.
          - A final `npm install` was run to ensure consistency.
          
          **Note:** While excluded package specifiers in `package.json` are restored, their resolved versions in `package-lock.json` might still change if updates to other packages create unavoidable dependency conflicts.
          
          ### ✅ Pre-merge Checklist
          - [ ] Review `package.json` and `package-lock.json` for intended changes.
          - [ ] Verify that excluded packages (by name or substring) behave as expected.
          - [ ] Run tests locally to verify compatibility.
          
          ### 🔍 How to Test Locally
          ```bash
          # The branch name will be: ${{ steps.vars.outputs.branch_name }}
          git fetch origin
          git checkout ${{ steps.vars.outputs.branch_name }}
          npm install
          npm test
          npm run build
          ```
          
          ---
          *This PR was created automatically by GitHub Actions*
        branch: ${{ steps.vars.outputs.branch_name }}
        delete-branch: true